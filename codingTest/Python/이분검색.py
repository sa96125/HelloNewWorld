# 이분 검색
# 임의의 N(3<n <0,000,000)개의 숫자가 입력으로 주어집니다. N개의 수를 오름차순으로 정렬한 다음
# N개의 수 중 한개의 수인 M이 주어지면 이분검색으로 M이 주어진 상태에서 몇 번째에 있는지
# 구하는 프로그램을 작성하시오. 단 중복값은 존재하지 않는다.
# ⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈

n, m = map(int, input().split())
arr_Number = list(map(int, input().split()))
target_Left = 0
target_Right = n-1

arr_Number.sort()
while target_Left <= target_Right:
    mid = (target_Left+target_Right)//2
    if arr_Number[mid] == m:
        print(mid+1)
        break
    elif arr_Number[mid] > m:
        target_Right = mid-1
    else:
        target_Left = mid+1

# ⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇
# 풀이: 100만개의 범위를 1초안에 오름차순으로 정렬하기 위해서는 퀵정렬을 사용할 수 없다.

# 문제:
#   기본정으로 O(n)을 사용해야하는데 내가 아는 기준에서는 삽입정렬을 이미 오름차순으로 정렬된 값비교를 할때로 알고 있다.

# 해결:
#   이분검색은 범위를 반으로 줄여 O(logn)을 가진다.
#   따라서 오름차순 정렬 후에 이분검색을 사용하여 시간 복잡도를 줄인다.

# 느낀점:
#   열심히 공부하자. 아 이런것도 빨리 못풀다니 아오 열받아
#   근데 애초에 문제가 이상하다 100만개의 숫자를 주어지게 해놓고 퀵정렬을 사용한다는 건 잘못된거 아닌가?
