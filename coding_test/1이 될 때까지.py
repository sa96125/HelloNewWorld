# 1이 될 때까지
# 어떠한 수 N이 1이 될 때까지 다음 두 과정중 하나만 선택하여 반복적으로 수행하려고 합니다.
# 단, 두번째 연산은 나누어떨어질때만 선택할 수 있습니다.
# 1. 1을 뺀다.
# 2. K로 나눈다.
# N과 K가 주어질 때 N이 1이 될 때까지의 수행해야하는 최소 횟수를 구하는 프로그램을 작성하세요.
# ⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈⨈

n, k = map(int, input().split())
cnt = 0

while(True):
    if k > n:
        break
    if n % k != 0:
        cnt += n-(n//k)*k
        n = (n//k)*k
    else:
        n = n//k
        cnt += 1

cnt += n-1
print(cnt)

# ⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇⨇
# 풀이: 그리드알고리즘

# 문제:
#   더이상 나눌수 없는 값에서 1이 될때까지의 예외

# 해결:
#   브레이크포인트를 하나하나 머리속에 대입하여 풀이.

# 느낀점:
#   O(logn)의 시간복잡도로 만드는 트릭이 정말 재미있는 요소중하나 였던 문제.
#   항상 문제를 해결할 때 추측성으로 풀지 않아야 하며 그로 인한 오답을 해결하는데 엄청난 시간을 소모하게된다.
