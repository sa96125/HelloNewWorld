# 상하좌우(구현)

# 여행가 A는 N*N 크기의 정사격형 공간 위에 서 있습니다. 이 공간은 1x1 크기의 정사각형으로 나누어져 있습니다.
# 가장 왼쪽 위 좌표는(1, 1)이며, 가장 오른쪽 아래좌표는(N, N)에 해당합니다.
# 여행가 A는 상, 하, 좌, 우 방향으로 이동할 수 있으며, 시작좌표는 항상(1, 1)입니다.
# 우리 앞에는 여행가 A가 이동할 계획이 적힌 계획서가 놓여 있습니다.

# 계획서 하나에 줄 띄어쓰기 기준으로 하여 L, R, U, D 중 하나의 문자가 반복적으로 적혀 있습니다.
# 각문자의 의미는 다음과 같습니다.

# L: 왼쪽으로 한칸이동
# R: 오른쪽으로 한칸
# U: 위로 한칸
# D: 아래로 한칸

n = int(input())
plan = list(input().split())
locationA = [1, 1]  # 초기 값 셋팅
move = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}
# 파이썬은 스위치문이 없어서 딕셔너리로 대체했다.

for i in range(len(plan)):
    if locationA[1]+move[plan[i]][1] <= 0 or locationA[1]+move[plan[i]][1] > n or locationA[0]+move[plan[i]][0] <= 0 or locationA[0]+move[plan[i]][0] > n:
        continue  # 범위를 벗어나면 그냥 다음차례로
    if plan[i] == 'L':
        locationA[1] += move['L'][1]
    elif plan[i] == 'R':
        locationA[1] += move['R'][1]
    elif plan[i] == 'U':
        locationA[0] += move['U'][0]
    else:
        locationA[0] += move['D'][0]

print(locationA)

# # 느낀점.
# 일단 파이썬에는 switch문이 없어서 dict 자료구조를 사용해서 만들었다.
# 문제풀이는 시간복잡도 O(n**2)를 가졌지만 나는 O(n)으로 풀이하여 훨씬 더 효율이 좋은 코드를 만들어 뿌듯했다.
# 넘파이에서 행렬의 덧셈이 가능해서 +를 했더니 배열끼리 붙이는 효과가 나서 거기서 실수 한번하고,
# 배열에 문자가 들어가있을 때, 인덱스와의 관계를 잘 생각해야했다.
# 딕셔니리 구조를 사용할 때 키값을 정의하는 양식, 부르는 양식 또한 익숙해질 수 있어 아주 재미있었다.
